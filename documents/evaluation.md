# Preliminary Evaluation - EasyTeX, Paul Dapolito

## What works well? What are you particularly pleased with?

I am very pleased with the progress I have made thus far on EasyTeX. The language is implemented as an external DSL which is hosted in Python. I wrote a robust [parser](https://github.com/PaulDapolito/EasyTeX/blob/master/source/parser/parser.py) for the language using Python's [pyparsing](http://pyparsing.wikispaces.com/) module, as well as a thorough [testing suite](https://github.com/PaulDapolito/EasyTeX/blob/master/source/tests/parser_tests.py) for the parser. At this point, EasyTeX's parser is working quite well, as it successfully both of the [sample documents](https://github.com/PaulDapolito/EasyTeX/tree/master/samples) that I have placed at the root of the project as well as the plethora of [test documents](https://github.com/PaulDapolito/EasyTeX/tree/master/source/tests/test_text_files) included in the project's testing suite. I feel that a major strength of EasyTeX's parser is its ability to parse components of EasyTeX documents to named parameters. This means that, when the parser is run against a properly formatted EasyTeX document, each component of the document will be associated with an aptly-named key in a Python dictionary. For instance, if a document includes some number of collaborators, this component will be parsed as the value of `"collaborators"` in a dictionary. Prof. Ben suggested this functionality to me during class, and I am very pleased that I was able to implement it by using the parsing module's `setResultsName` modifier. I did not realize at the time of implementation, but this characteristic of EasyTeX's parser has allowed me to design the language's syntax to be less restrictive. Thanks to the parser's named, rather than linearly indexed, components, EasyTeX supports the arbitrary ordering and inclusion of many components of a user's document. For instance, in declaring the header fields associated with a problem set, a user who takes advantage of all of EasyTeX's informative specifications might state:

    author: Paul Dapolito
    collaborators: Robert, Angela, Daniel
    due_date: September 21, 2015
    title: Super \underline{Advanced} Title
    course: \textbf{Domain-Specific} Languages
    school: Harvey Mudd College

By taking advantage of EasyTeX's optional and arbitrarily ordered fields, a more minimalistic user could also state:

    title: Super \underline{Advanced} Title
    author: Paul Dapolito

This flexibility in the language's syntax was entirely enabled by the parser's ability to create named results, and I am very pleased with how this functionality has allowed EasyTeX to be more user-friendly and less restrictive.

I am similarly pleased with EasyTeX's [internal representation](https://github.com/PaulDapolito/EasyTeX/tree/master/source/ir). Because different types of EasyTeX documents may share similar component types, I have implemented the language's internal representation in a way which is easily shareable and easily extensible. This means that, later on, I can add components to the language and integrate these components into the language's internal representation very easily. In addition to being modular, EasyTeX's internal representation performs important data-validation and handles errors in a way which allows users to quickly and easily identify their errors. Every component of an EasyTeX document has its own [error class](https://github.com/PaulDapolito/EasyTeX/tree/master/source/errors/ir), so any error encountered while instantiating EasyTeX's internal representation is associated with a unique EasyTeX component. This functionality, combined with the validation performed when any component of an EasyTeX document is internally instantiated, assures that a user's data creates a valid internal representation or they are otherwise notified of problematic input in a helpful way.

If a user's input yields a valid internal representation, EasyTeX's interpreter implements the language's semantics in a way which is efficient and well-tested. Because EasyTeX currently supports two different types of documents, I have implemented and tested interpreters for both [memorandums](https://github.com/PaulDapolito/EasyTeX/blob/master/source/interpreters/memorandum_interpreter.py) and [problem sets](https://github.com/PaulDapolito/EasyTeX/blob/master/source/interpreters/problem_set_interpreter.py). In the spirit of implementing EasyTeX in modular fashion, I encapsulated both of these interpreters in a single and all-inclusive [EasyTeX interpreter](https://github.com/PaulDapolito/EasyTeX/blob/master/source/interpreters/interpreter.py). I am particularly pleased with how seamlessly EasyTeX's interpretation process is working, and I suspect that this is achieved due to the interpreters being implemented in pure Python and without any reliance on third-party tools. In order to assure that EasyTeX's interpreter is robust and precise as I continue to expand the project, I have also implemented a thorough [testing suite](https://github.com/PaulDapolito/EasyTeX/blob/master/source/tests/interpreter_tests.py) for the interpreter. I am very pleased that the interpreter properly handles all of the internal representations yielded by the aforementioned test documents. 

In my previous week of work on the project, I implemented end-to-end PDF generation such that EasyTeX can now take a user's text file in the EasyTeX specification and create a PDF file. This process is manifested using a command-line [shell script](https://github.com/PaulDapolito/EasyTeX/blob/master/easytex.sh), and I am extremely pleased at how quickly the program can create a PDF file (in fact, EasyTeX operates more quickly than most LaTeX environments!). The shell script implicitly, using the [easytex.py](https://github.com/PaulDapolito/EasyTeX/blob/master/source/easytex.py) driver file, invokes both of EasyTeX's parser and interpreter as well as a LaTeX-to-PDF tool on the command-line. This functionality relies on the modularity of EasyTeX's implementation, and I am extremely pleased with how well the different components of EasyTeX interact when brought together to generate PDFs for EasyTeX users. 

Intertwining such a diverse array of software tools meant incorporating a fair number of dependencies into the project (more on this later), and because of this, I spent a fair amount of time documenting [EasyTeX's installation and usage procedures](https://github.com/PaulDapolito/EasyTeX/blob/master/README.md). I was initially worried about how complicated this process might be, but in reviewing the [feedback I received last week](https://github.com/PaulDapolito/EasyTeX/blob/master/critiques/November%2025.md), I am pleased to see that at least one other user found this installation and execution process to be manageable. I feel that streamlining EasyTeX's installation process has been facilitated by both the [bootstrap](https://github.com/PaulDapolito/EasyTeX/blob/master/bootstrap.sh) script included with the project as well as Python's [virtualenv](http://virtualenv.readthedocs.org/en/latest/) module, and I am very pleased with the convenience that these inclusions will offer EasyTeX users.

## What could be improved? For example, how could the user's experience be better? How might your implementation be simpler or more cohesive?

In thinking about EasyTeX's installation and the associated dependencies, I am quite disappointed with how much additional software the project requires the user to do in order to simply try-out and use the language. I feel that the project has too many dependencies, and I think that EasyTeX's users will have a better experience if I find a way to consolidate the setup process more than I already have. As is mentioned in the installation instructions in the project's [README](https://github.com/PaulDapolito/EasyTeX/blob/master/README.md), EasyTeX depends on a command-line tool (`pdflatex`) in order to create PDF documents for users. This command-line tool is usually included as part of a much larger LaTeX installation, which may be anywhere from 10MB to 2GB in size. I am quite disappointed with how much overhead this adds to the project, and I have been actively exploring alternative ways to allow for the creation of PDF documents from `.tex` files. Most LaTeX installations are also customizable and highly configurable as to what formatting packages are applied to users' documents. At the moment, EasyTeX does not allow users to specify much of the formatting components of their documents, and I really feel that allowing for such configuration would make user experiences with the DSL much better. For now, EasyTeX simply uses [hmcpset](https://www.math.hmc.edu/computing/support/tex/classes/hmcpset/) to format a user's EasyTeX document, and I am hoping to improve this formatting configuration to be more customizable so that EasyTeX users can incorporate other styling sheets and packages into their typeset documents.

One of EasyTeX's major strengths over LaTeX is the DSL's use of whitespace and tabbed-delineation to demarcate the start and end of document components. While this paradigm seems like a great design for the language in theory, I have had a lot of trouble enforcing the whitespace standards that I envisioned for the language in EasyTeX's implementation. I am quite displeased with how the language enforces whitespace demarcation at this point, and I hope to incorporate more strict enforcement of the language's whitespace standards in the final weeks of the project. Expressing EasyTeX's whitespace rules and standards in a readable way has also been quite challenging, and I am unhappy with how I have currently expressed the languages syntax to users. The language's [grammar](https://github.com/PaulDapolito/EasyTeX/blob/master/documents/grammar.md) does not currently express the whitespace standards that I had in mind for the language, and I am discontent with how this document generally conveys the language's syntax to EasyTeX users. Further compounding this problem is the lack of a native editing environment for EasyTeX. I have not yet developed an environment for EasyTeX that incorporates syntax highlighting, so EasyTeX users may be in-the-dark as to how well their document meets EasyTeX's specifications until compile-time. I feel that this characteristic of using the language is not ideal for a user's experience, and I hope to provide some way for users to receive real-time feedback on their documents during the editing process. 

In implementing a thorough testing framework for EasyTeX's interpretation process, I did not incorporate proper [mocking](http://en.wikipedia.org/wiki/Mock_object). This means that the tests for EasyTeX's interpreters rely on the language's parser functioning correctly. I feel that this is a major flaw in the language's implementation, but I had to exclude mocking in the best interest of time. I hope to re-enter the project at some point in the future and use Google's [pymox](https://code.google.com/p/pymox/) module in order to deliver a testing suite for the language which is more robust and more modular. 

## Re-visit your evaluation plan from the beginning of the project. Which tools have you used to evaluate the quality of your design? What have you learned from these evaluations? Have you made any significant changes as a result of these tools, the critiques, or user tests?

In my evaluation plan from the beginning of the project, I mentioned that I would evaluate the quality of EasyTeX's design using a thorough testing suite. I have indeed gone about implementing a [testing framework](https://github.com/PaulDapolito/EasyTeX/tree/master/source/tests) for the language, which evaluates the function of EasyTeX's parser and interpreter to assure that both operate in an expected fashion and produce proper results. This testing suite utilizes a large number of sample [text files](https://github.com/PaulDapolito/EasyTeX/tree/master/source/tests/test_text_files) to ensure that the language's parser and interpreter can handle a wide array of user input in accordance with EasyTeX's specification. In implementing this testing suite as part of evaluating EasyTeX, I have learned the true value of test-driven development. Having a thorough testing suite was instrumental when expanding EasyTeX, as I was able to ensure that each iteration of development continued to satisfy the plethora of tests that I had created for the language.

EasyTeX's testing framework is also accompanied by, as is mentioned in my evaluation plan, a [code coverage module](https://pypi.python.org/pypi/coverage). This utility runs all of EasyTeX's tests and then creates an HTML interface to present the code coverage of the testing framework: 

<div id="container" style="width: 500px" align="center">
    <img src="http://i.imgur.com/da4LuVZ.png"/> <br />
</div>

Using this module, I can explore various files within the project and evaluate how well EasyTeX's testing suite evaluates components of the language's implementation. The module shows me exactly what lines of code are covered when the testing framework is executed. For example, in evaluating the code coverage of the tests for EasyTeX's parser, the module highlights lines which are not reached by the test code:

<div id="container" style="width: 500px" align="center">
    <img src="http://i.imgur.com/3meiIF5.png"/> <br />
</div>

In using this tool, I learned that I needed to be more careful in implementing tests for EasyTeX. Throughout the various iterations of design and development work on the project, I have focused on my insistence that the language handles errors in an appropriate fashion. However, in implementing tests for EasyTeX, I often excluded tests for error cases, as the above example elucidates. I learned that it is very important to include test cases within any testing framework that evaluates the behavior of software for both valid and invalid input, and given this knowledge, I have integrated several tests into the testing framework which present EasyTeX with invalid input and assure that appropriate errors are raised: 

<div id="container" style="width: 500px" align="center">
    <img src="http://i.imgur.com/4zXi7HE.png"/> <br />
    <img src="http://i.imgur.com/sC617mq.png"/> <br />
</div>

In addition to learning the value of making full use of the range of testing tools available, I learned that user testing is essential in creating good software. By way of in-class feedback, critique partners, and soliciting the feedback of my peers, I have gotten a lot of feedback on EasyTeX from potential users. Much of the feedback I have been given has been immediately incorporated into EasyTeX. For instance, a few weeks into the project, my critique group said that I should focus on creating EasyTeX's parser and its associated tests from a holistic view, such that I should develop the parser and its tests with the intention of parsing full documents. Up to that point, I had only implemented the parser and its tests in discrete components, and trying to interleave these components was time-consuming and quite challenging. I thus focused on developing a parser, in a single iteration, that could parse an entire EasyTeX problem set. To accompany this development with proper tests, I also created a test problem set document. I built upon this by expanding EasyTeX's parser to parse an entire EasyTeX memorandum, and created a test memorandum by which to test this functionality of the parser. As I continued to expand EasyTeX's syntax and parser, I did this with a focus on full EasyTeX documents, which was a quintessential piece of feedback that I received from my critique group.  

User testing has also had a significant impact on EasyTeX's syntax. In soliciting feedback from some of my peers, I learned that an EasyTeX user might feel restricted if the language was implemented to enforce the meaningless ordering of a document's header components, such as a document's author, collaborators, date, and title. There was truly no reason to have EasyTeX enforce some ordering of these fields, and I only incorporated strict ordering of these components into the language because an ordering seemed to lend itself well to the language's parser. However, upon soliciting some feedback on the language from my peers, I soon realized that I needed to incorporate such components into EasyTeX documents in a way that does not enforce a particular ordering, which is featured in the current version of EasyTeX.

## Where did you run into trouble and why? For example, did you come up with some syntax that you found difficult to implement, given your host language choice? Did you want to support multiple features, but you had trouble getting them to play well together?

In creating EasyTeX's parser, I quickly realized that I had chosen the wrong parsing module for the project. The parsing module I am working with, [pyparsing](http://pyparsing.wikispaces.com/), is scantily documented and hardly supported on the Internet. I tried to find alternatives to this module early-on in the project, and I ultimately could not find an alternative that was sufficiently different. I should have probably used the Python parsing module that Alejandro is using, [pyPEG](http://fdik.org/pyPEG/), but I feel that I am currently too far along in the project's development to step back on this decision.

Adding to the difficulty associated with this parser was my attempts at parsing EasyTeX's tab-delineated syntax. I designed the language with the intention that users would not use opening-and-closing tags to delineate different components of their documents. Rather than using these verbose demarcations, I decided to incorporate tabbed-delineation into the language's syntax. I soon learned that developing a parser to comprehend this syntax was immensely difficult. The parsing module I used does not natively supported tabbed indentations, and I spent a lot of time working with the hardly documented `indentedBlock` expression included in the module. Because I wanted EasyTeX users to be free to incorporate any expressions into the contents of their documents, my parser implementation had a lot of trouble parsing the unbounded text of one component while recognizing the existence of the next section. This issue of EasyTeX's tabbed-delineation was very hard to overcome, and I ultimately had to incorporate regular expressions into the language's parser in order to successfully parse nested and tab-indented blocks within EasyTeX documents:

<div id="container" style="width: 500px" align="center">
    <img src="http://i.imgur.com/49eBRPJ.png"/> <br />
</div>

EasyTeX's design incorporates components which are optional, such as the `subtitle` of an EasyTeX memorandum, or the `collaborators` of an EasyTeX problem set. EasyTeX's design also allows for the arbitrary ordering of many of these components that might be included at the top of an EasyTeX document. To allow for the optional ordering of EasyTeX components, and as suggested to me by Prof. Ben, I implemented EasyTeX's parser to assign dictionary keys (names) to each component to allow these components to be accessed by name:

<div id="container" style="width: 500px" align="center">
    <img src="http://i.imgur.com/xEcgl34.png"/> <br />
    <img src="http://i.imgur.com/KRrjvno.png"/> <br />
</div>

Combining the allowance of any ordering of these EasyTeX components as well as the option to simply exclude any of these 
components was quite challenging, for attempting to access an excluded element by its name in a Python dictionary results in a `KeyError`. To surmount this problem while avoiding the implementation of `try`, `except` blocks, I specified default values for each component of an EasyTeX document to assure that, even in the case of some element being excluded from a user's document, the excluded component is still accessible by name. I reached this implementation solution after spending a lot of time exploring the functionality of pyparsing's `setResultsName` method. I am pleased that I was able to solve this problem, as it will allow the expansion and growth of EasyTeX to take place more easily.

In implementing end-to-end PDF generation within EasyTeX, I was challenged while working with the `pdftolatex` command-line tool. In order to use this tool, an EasyTeX user must have a full (and huge) LaTeX package installed on their workstation. I tried to find some alternative to this massive installation in the open-source world, and I was unsuccessful, so for the time being, EasyTeX does indeed depend on the installation of a LaTeX package in order to generate PDF documents for users. Further compounding this challenge is EasyTeX's current reliance on the [hmcpset](https://www.math.hmc.edu/computing/support/tex/classes/hmcpset/) styling package. I have had a lot of trouble working with LaTeX's package system, and EasyTeX currently assumes that users have hmcpset installed in the relevant directory within their LaTeX setup. I am hoping to rectify this assumption in the final weeks of the project and further expand EasyTeX to allow users to specify their own styling packages in EasyTeX documents. 

## What's left to accomplish before the end of the project?

   + As I have mentioned throughout this document, I am intent on allowing EasyTeX users to specify formatting and styling configuration options of their documents. EasyTeX currently relies on the use of the hmcpset LaTeX styling package, and I would like to expand the language to allow users to specify their own styling packages or document configuration options.

   + In light of EasyTeX's strict dependence on LaTeX, I would like to streamline the language's installation process. I will continue investigating alternative LaTeX-to-PDF tools in order to make this process take up less space and be a bit more manageable. I would especially like the installation process to equip users with all of the necessary LaTeX packages that are required for using the language.

   + I intend on bolstering EasyTeX's parser to be more strict about the language's whitespace standards and tabbed-delineation requirements. At the moment, EasyTeX's parser may not enforce tab-delineation for particular EasyTeX components, and I would like to strictly enforce tabbed-delineation as a standard for the language within EasyTeX's parser.

   + I would like to find or a develop a way to present EasyTeX to users in the most readable way. At the moment, EasyTeX users can learn the language by referring to EasyTeX's grammar or by exploring some of the sample documents scattered throughout the GitHub project. I would like to present EasyTeX's syntactic specification in a more readable form, and I would also like to present users with a wider range of sample documents.

   + I would like to deliver the language to some freshmen at Harvey Mudd College in the interest of soliciting feedback. This would require meeting with potential users one-on-one and observing their experiences with the software's installation process, as well as soliciting feedback from the users on their experiences using the tool from their native command-line. I feel that feedback from potential users will be invaluable in fine-tuning the language in the final weeks of the project.

   + If time allows, I would like to develop an interface by which EasyTeX users can receive real-time feedback on their documents. I had originally intended to develop this interface using web technologies, but I have learned that a Sublime Text plugin or similar alternative might accomplish the same goal of providing real-time feedback and informative syntax highlighting for EasyTeX users.

